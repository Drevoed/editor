{"version":3,"file":"prism.js","sourceRoot":"","sources":["prism.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,MAAM,SAAS,CAAA;AAC3B,OAAO,EAAU,IAAI,EAAoB,MAAM,OAAO,CAAA;AAEtD,OAAO,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,sBAAsB,CAAA;AAEpE,MAAM,CAAC,MAAM,KAAK,GAAc,CAAC,MAAc,EAAE,KAAgB,EAAE,EAAE;IACnE,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,KAAK,CAAA;IAE1B,MAAM,UAAU,GAAG,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC,CAAA;IAC5D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QAAE,OAAO,EAAE,CAAA;IAEhC;;OAEG;IACH,MAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAc,MAAM,EAAE;QAC5D,EAAE,EAAE,IAAI;QACR,IAAI,EAAE,OAAO;QACb,KAAK,EAAE,cAAc,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC;KAC5C,CAAC,CAAA;IACF,IAAI,CAAC,SAAS;QAAE,OAAO,EAAE,CAAA;IACzB,MAAM,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAA;IAE5B,MAAM,MAAM,GAAY,EAAE,CAAA;IAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAE9B,MAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAA;IAEvE,IAAI,MAAM,GAAG,CAAC,CAAA;IACd,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;QAC1B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B;;;eAGG;YAEH,MAAM,IAAI,KAAK,CAAC,MAAM,CAAA;YACtB,SAAQ;SACT;QAED;;;;;WAKG;QAEH,MAAM,CAAC,IAAI,CAAC;YACV,MAAM,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE;YACxB,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE;YAC9C,UAAU,EAAE,KAAK,CAAC,IAAI;SACvB,CAAC,CAAA;QAEF,MAAM,IAAI,KAAK,CAAC,MAAM,CAAA;KACvB;IAED,OAAO,MAAM,CAAA;AACf,CAAC,CAAA","sourcesContent":["import type { CodeElement } from '../elements'\nimport Prism from 'prismjs'\nimport { Editor, Node, NodeEntry, Range } from 'slate'\nimport type { Decorator } from '@cardbox-editor/core'\nimport { GlobalMatchers, GlobalQueries } from '@cardbox-editor/core'\n\nexport const prism: Decorator = (editor: Editor, entry: NodeEntry) => {\n  const [node, path] = entry\n\n  const isCodeLine = GlobalMatchers.block(editor, 'code-line')\n  if (!isCodeLine(node)) return []\n\n  /*\n   * We need the 'code' node to get the highlight language\n   */\n  const codeEntry = GlobalQueries.getAbove<CodeElement>(editor, {\n    at: path,\n    type: 'block',\n    match: GlobalMatchers.block(editor, 'code'),\n  })\n  if (!codeEntry) return []\n  const [codeNode] = codeEntry\n\n  const ranges: Range[] = []\n  const text = Node.string(node)\n\n  const tokens = Prism.tokenize(text, Prism.languages[codeNode.language])\n\n  let offset = 0\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      /*\n       * The token is just a string, without any special highlight\n       * So, we can just render as a simple string\n       */\n\n      offset += token.length\n      continue\n    }\n\n    /*\n     * The token is a Prism.Token\n     * We need its 'type' and 'length' props\n     * With 'length' we can \"select\" the right portion of code line string\n     * And with 'type' we can tell the 'renderLeaf' what className should be used\n     */\n\n    ranges.push({\n      anchor: { path, offset },\n      focus: { path, offset: offset + token.length },\n      prismToken: token.type,\n    })\n\n    offset += token.length\n  }\n\n  return ranges\n}\n"]}